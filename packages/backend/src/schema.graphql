scalar BigInt
scalar Timestamp

type Query {
  address(addressOrEnsName: String!): Address

  wrappedDelegates(
    where: WrappedDelegatesWhere
    orderBy: WrappedDelegatesOrder! = mostRelevant
    first: Int!
    after: String
  ): WrappedDelegatesConnection!

  proposals: [Proposal!]!
}

type Vote {
  id: ID!
  reason: String!
  # todo: this should be an enum
  supportDetailed: Int!
  votes: BigInt!

  proposal: Proposal!
  voter: Delegate!
  transaction: Transaction!
}

type Transaction {
  id: ID!
  hash: String!
  block: Block!
}

type Block {
  id: ID!
  number: BigInt!

  timestamp: Timestamp!
}

type Address {
  resolvedName: ResolvedName!
  account: Account
  wrappedDelegate: WrappedDelegate!
  isContract: Boolean!
}

type ResolvedName {
  address: ID!
  name: String
}

type WrappedDelegate {
  id: ID!
  address: Address!
  statement: DelegateStatement

  delegate: Delegate
}

type DelegateMetrics {
  totalVotes: Int!
  forVotes: Int!
  againstVotes: Int!
  abstainVotes: Int!
  ofLastTenProps: Int!
  ofTotalProps: Int!
  proposalsCreated: Int!
}

type TokenAmount {
  amount: BigInt!
  currency: String!
  decimals: Int!
}

type VotingPower {
  amount: TokenAmount!

  bpsOfQuorum: Int!
  bpsOfTotal: Int!
}

type Delegate {
  id: ID!
  address: Address!

  tokensRepresented: VotingPower!
  tokenHoldersRepresented: [Account!]!

  proposed: [Proposal!]!
  votes: [Vote!]!
  delegateMetrics: DelegateMetrics!
}

# Ownership and delegation information about an address.
type Account {
  id: ID!
  address: Address!

  amountOwned: VotingPower!

  # Delegate where voting power has been delegated. Can be delegated to a
  # delegate with the same address as the account.
  delegatingTo: Delegate!
}

type DelegateStatement {
  statement: String!
  summary: String
  topIssues: [TopIssue!]!
  mostValuableProposals: [Proposal!]!
  leastValuableProposals: [Proposal!]!
  twitter: String!
  discord: String!
  openToSponsoringProposals: Boolean
}

type TopIssue {
  type: String!
  value: String!
}

enum WrappedDelegatesWhere {
  withStatement
  seekingDelegation
}

enum WrappedDelegatesOrder {
  mostRelevant
  mostVotingPower
  mostActive
}

type WrappedDelegatesConnection {
  pageInfo: PageInfo!
  edges: [WrappedDelegatesEdge!]!
}

type WrappedDelegatesEdge {
  node: WrappedDelegate!
  cursor: String!
}

type PageInfo {
  count: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Proposal {
  id: ID!
  number: BigInt!
  title: String!
  totalVotes: BigInt!
  votes: [Vote!]!

  totalValue: BigInt!

  proposer: Delegate!
}

type Mutation {
  createNewDelegateStatement(
    data: CreateNewDelegateStatementData
  ): WrappedDelegate!
}

input CreateNewDelegateStatementData {
  statement: ValueWithSignature!
  email: ValueWithSignature
}

input ValueWithSignature {
  # Address of the signer, this is used for logging and so we can implement
  # gnosis wallet multi-sig signature verification.
  signerAddress: String!
  value: String!
  signature: String!
}

