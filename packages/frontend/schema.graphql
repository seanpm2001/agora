scalar BigInt

scalar Timestamp

type Query {
  delegate(addressOrEnsName: String!): Delegate
  delegates(where: DelegatesWhere, orderBy: DelegatesOrder!, first: Int!, after: String): DelegatesConnection!
  proposal(id: ID!): Proposal!
  proposals: [Proposal!]!
  metrics: Metrics!
}

type Delegate {
  id: ID!
  address: Address!
  statement: DelegateStatement
  amountOwned: VotingPower!
  tokensRepresented: VotingPower!
  delegateMetrics: DelegateMetrics!
  proposed: [Proposal!]!
  votes: [Vote!]!
  snapshotVotes: [SnapshotVote!]!
}

type Address {
  resolvedName: ResolvedName!
  isContract: Boolean!
}

type DelegateStatement {
  statement: String!
  summary: String
  topIssues: [TopIssue!]!
  mostValuableProposals: [Proposal!]!
  leastValuableProposals: [Proposal!]!
  twitter: String!
  discord: String!
  openToSponsoringProposals: Boolean
}

type ResolvedName {
  address: ID!
  name: String
}

type DelegateMetrics {
  totalVotes: Int!
  forVotes: Int!
  againstVotes: Int!
  abstainVotes: Int!
  ofLastTenProps: Int!
  ofTotalProps: Int!
  proposalsCreated: Int!
  tokenHoldersRepresentedCount: Int!
}

type Metrics {
  delegatedSupply: TokenAmount!
  totalSupply: TokenAmount!
  quorum: VotingPower!
  proposalThreshold: VotingPower!
}

type Vote {
  id: ID!
  reason: String!
  supportDetailed: Int!
  votes: VotingPower!
  proposal: Proposal!
  voter: Delegate!
  transaction: Transaction!
}

type Transaction {
  id: ID!
  hash: String!
  block: Block!
}

type Block {
  id: ID!
  number: BigInt!
  timestamp: Timestamp!
}

type TokenAmount {
  amount: BigInt!
  currency: String!
  decimals: Int!
}

type VotingPower {
  amount: TokenAmount!
  bpsOfQuorum: Int!
  bpsOfTotal: Int!
}

type SnapshotVote {
  id: ID!
  choice: SnapshotVoteChoice!
  votingPower: Float!
  proposal: SnapshotProposal!
  createdAt: Timestamp!
  reason: String!
}

union SnapshotVoteChoice = SnapshotVoteChoiceApproval | SnapshotVoteChoiceRanked | SnapshotVoteChoiceSingle | SnapshotVoteChoiceQuadratic | SnapshotVoteChoiceWeighted

type SnapshotVoteChoiceApproval {
  approvedChoices: [Int!]!
}

type SnapshotVoteChoiceRanked {
  choices: [Int!]!
}

type SnapshotVoteChoiceSingle {
  selectedChoiceIdx: Int!
}

type SnapshotVoteChoiceQuadratic {
  weights: [WeightedSelectedChoice!]!
}

type SnapshotVoteChoiceWeighted {
  weights: [WeightedSelectedChoice!]!
}

type WeightedSelectedChoice {
  choiceIdx: Int!
  weight: Int!
}

type SnapshotProposal {
  id: ID!
  title: String!
  link: String!
  choices: [ProposalChoice!]!
}

type ProposalChoice {
  title: String!
  score: Float!
}

type TopIssue {
  type: String!
  value: String!
}

enum DelegatesWhere {
  withStatement
  withoutStatement
}

enum DelegatesOrder {
  mostVotingPower
  mostDelegates
}

type DelegatesConnection {
  pageInfo: PageInfo!
  edges: [DelegatesEdge!]!
}

type DelegatesEdge {
  node: Delegate!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

scalar Bytes

type Proposal {
  id: ID!
  number: BigInt!
  forVotes: BigInt!
  againstVotes: BigInt!
  abstainVotes: BigInt!
  title: String!
  description: String!
  voteEndsAt: Int!
  voteStartsAt: Int!
  quorumVotes: BigInt!
  totalVotes: BigInt!
  votes: [Vote!]!
  targets: [Bytes!]
  values: [BigInt!]
  signatures: [String!]
  calldatas: [Bytes!]
  status: ProposalStatus!
  totalValue: BigInt!
  proposer: Delegate!
}

enum ProposalStatus {
  PENDING
  ACTIVE
  CANCELLED
  VETOED
  QUEUED
  EXECUTED
  DEFEATED
  EXPIRED
}

type Mutation {
  createNewDelegateStatement(data: CreateNewDelegateStatementData): Delegate!
}

input CreateNewDelegateStatementData {
  statement: ValueWithSignature!
  email: ValueWithSignature
}

input ValueWithSignature {
  signerAddress: String!
  value: String!
  signature: String!
}
